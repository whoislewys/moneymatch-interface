
/* import * as IPFS from 'ipfs' */
/* import OrbitDB from 'orbit-db' */
/// orbitdb experiment
/// i think recreating the hash on all peers will work since the usernames are known, just recreate the db with the same arguments
/// /orbitdb, specifies the protocol in use. The second part, an IPFS multihash Qmd8TmZrWASypEp4Er9tgWP4kCNQnW4ncSnvjvyHQ3EVSU, is the database manifest which contains the database info such as the name and type, and a pointer to the access controller. The last part, first-database, is the name of the database.

import {useEffect, useState} from "react";

/// how the fuck does orbit-chat work though, with the peer discovery???

/// or dis: https://github.com/orbitdb/web3-workshop
/// this post may help: https://jeremyorme.com/creating-a-peer-to-peer-web-app-with-orbitdb-and-stenciljs-92d8d912e87b

const OrbitDBRoom = () => {
  const [db, setDb] = useState<any>();
  const {data: test123Address, isError, isLoading} = useEnsAddress({
    name: 'test123.eth',
  });
  // Initialize DB
  useEffect(() => {
    (async () => {
      if (address) {
        // TODO: get signer for opponents .eth address
        const opponentIdentity = await Identities.createIdentity({
          type: "ethereum",
          test123Address,
        });
        console.log('Opponent OrbitDB identity: ', opponentIdentity);

        try {
          const connectedPlayerIdentity = await Identities.createIdentity({
            type: "ethereum",
            address,
          });
          console.log('connectedPlayerIdentity: ', connectedPlayerIdentity)

          try {
            const ipfsOptions = {repo: './ipfs', }
            const ipfs = await IPFS.create(ipfsOptions)

            // Create OrbitDB instance
            // https://github.com/orbitdb/orbit-db/blob/main/GUIDE.md#creating-an-identity
            // TODO: should probably create identity as compound key of eth address + slippi uname? would make it easier for other peer to connect
            const orbitdb = await OrbitDB.createInstance(ipfs, {identity: connectedPlayerIdentity});

            // Specify OrbitDB database
            const options = {
              // Give write access to ourselves
              accessController: {
                write: [connectedPlayerIdentity.id, opponentIdentity.id]
              }
            }
            const db = await orbitdb.log('moneymatch', options);
            setDb(db);
            // console.log('log db: ', db)
            // console.log('log db identity: ', db.identity.publicKey)

            // db.address: /orbitdb/zdpuArBijqpzxYSaGnew8gpvvtgeJKuQVHYQ9CBcKpwpyAqoY/moneymatch
            // middle part is multihash. can get data from it with: `ipfs dag get <multihash>`
          } catch (e) {
            console.error('Error creating OrbitDB instance: ', e);
          }

        } catch (e) {
          console.error('Error creating identity: ', e);
        }
      }
    }
    )();
  }, [address])

  const addAndGetTestEvent = async () => {
    // get a log db and add to it
    // https://github.com/orbitdb/orbit-db-eventstore
    console.log('adding event');
    // await db.add('[Game Complete] Type: GAME!');
    await db.add(eventText);
    console.log('gettinge events:');
    const value = db.iterator().collect().map((e: any) => {
      console.log('even: ', e);
    });
  };
}
